# Ассемблер x86, часть 2

## Интерфейс системных вызовов

Способ выполнения системного вызова сильно отличается на разных платформах. На платформе x86 системный вызов
выполняется следующим образом:
* номер системного вызова помещается в регистр `%eax`
* параметры системного вызова помещаются в регистры `%ebx`, `%ecx`, `%edx` (в зависимости от их количества)
* выполняется инструкция `int $0x80`

Номера системных вызовов находятся в заголовочном файле `<asm/unistd_32.h>`. Например, чтобы считать один символ со стандартного
потока ввода нужно выполнить системный вызов:
```
char c;
int val = read(0, &c, sizeof(c));
```

соответствующий фрагмент программы на ассемблере будет выглядеть следующим образом:
```
#include <asm/unistd_32.h>
        .data                   // размещаем данные
c:      .byte   0               // c - это глобальная переменная размера один байт (char)
        .text                   // начинаем секцию кода
        // ...
        movl    $__NR_read, %eax // или $3, %eax, если заголовочный файл не найден
        movl    $0, %ebx        // первый аргумент (0 - стандартный поток ввода) в %ebx
        movl    $c, %ecx        // второй аргумент (адрес переменной c) в %ecx
        movl    $1, %edx        // третий аргумент (размер переменной c) в %edx
        int     $0x80
        // в %eax будет возвращаемое значение read
```

системный вызов `exit(0);` на ассемблере запишется следующим образом:
```
        movl    $__NR_exit, %eax
        xorl    %ebx, %ebx
        int     $0x80
```

если файл `<asm/unistd_32.h>` недоступен, можно использовать численные значения:
```
#define __NR_exit 1
#define __NR_fork 2
#define __NR_read 3
#define __NR_write 4
```

## Стандартное соглашение о передаче параметров

В программах, написанных на языках высокого уровня, все функции вызываются некоторым стандартным образом. Это соглашение
может варьироваться в зависимости от операционной системы, процессора и языка программирования. Программы на языке Си
в операционных системах Unix на архитектуре x86 используют по умолчанию следующее соглашение о вызовах:

* параметры вызываемой функции передаются через стек
* результат вызываемой функции возвращается в регистре %eax, либо в регистрах %eax, %edx, если возвращается 64-битное значение.
* параметры, размер которых меньше 4 байт (char, short), передаются как 4-байтовые значения
* параметры заносятся в стек в обратном порядке, таким образом в стеке параметры лежат в прямом порядке
* стек от параметров очищается после возврата из вызванной функции
* вызываемая функция может испортить значения регистров `%eax`, `%edx`, `%ecx`.

Например, пусть мы хотим вывести на стандартный поток значение целой переменной value, которая хранится в регистре `%esi`.
Теперь, чтобы вывести на стандартный поток вывода строку
с помощью printf, 
```
        printf("Hello, %d\n", value); 
```

Потребуется следующий фрагмент на ассемблере:
```
        .text
msg1:   .asciz  "Hello, %d\n"   // определяем последовательность символов, которая завершается \0
        // ...
        pushl   %esi            // заносим в стек содержимое %esi
        pushl   $msg1           // заносим в стек адрес строки msg1
        call    printf
        addl    $8, %esp        // чистим стек
```

Не забывайте чистить стек после возврата из подпрограммы, в которую были переданы параметры!

Если для вывода используются функции стандартной библиотеки (`printf`), то и завершение программы
тоже должно выполняться средствами стандартной библиотеки (`exit`). Если после вызова `printf`
выполнить выход с помощью `int $0x80`, строка, переданная `printf` может просто пропасть.

## Стандартный пролог и эпилог функции

Выполнение программы обычно состоит из вычислений и вызовов функций, причем функции могут образовать длинную цепочку вызовов.
Рекурсивные функции многократно вызывают сами себя. Таким образом, во время работы программы на стеке формируется динамическая структура,
соответствующая состоянию программы.

Указатель стека хранится в переменной `%esp`. Стек растет в сторону уменьшения адресов, то есть по меньшим адресам находятся данные,
занесенные в стек позже. Работать со стеком можно только 32-битными операциями. Занести в стек один байт нельзя.

Инструкция `push ARG` выполняется следующим образом:
* регистр %esp уменьшается на 4: `subl $4, %esp`
* по новому адресу заносится значение `movl ARG, (%esp)`

Инструкция `pop ARG` выполняется в обратном порядке. Таким образом, регистр `%esp` хранит адрес последнего занесенного в стек 32-битного значения.

Как правило, компилятор С генерирует код подпрограмм, соблюдающий правила стандартного пролога и эпилога функций.

Стандартный пролог выглядит следующим образом:
```
        pushl   %ebp
        movl    %esp, %ebp
```

Сначала в стек заносится старое содержимое регистра `%ebp`, а затем в регистр `%ebp` копируется значение `%esp`.
Получится, что регистр `%ebp` хранит адрес в стеке, по которому находится значение регистра `%ebp` у предыдущей функции.
Для нее, в свою очередь, регистр `%ebp` хранил адрес в стеке, по которому находилось значение `%ebp` предыдущей к ней функции.
Так в стеке организован связный список фреймов вызванных функций. Начиная от текущей функции мы можем пройти по цепочке фреймов
функций до функции, которая была вызвана самой первой при старте программы.

Стандартный эпилог выполняет обратные действия:
```
        movl    %ebp, %esp      /* восстанавливается фиксированное значение %esp */
        popl    %ebp            /* восстанавливаем фрейм подпрограммы, которая вызвала нас */
        ret
```

Работа с данными, размещенными на стеке, как правило, ведется относительно регистра %ebp. С положительными смещениями относительно %ebp
находятся значения параметров функции, а с отрицательными - сохраненные значения регистров (если есть) и локальные переменные.

Рассмотрим функцию `func(int a, int b, int c, int d);`. После выполнения стандартного пролога работать с объектами на стеке можно так:
```
        movl    (%ebp), %edx    /* в %edx загружается старое значение %ebp */
        movl    4(%ebp), %eax   /* в %eax адрес, на который мы должны возвратиться по завершению функции */
        movl    8(%ebp), %eax   /* обращение к параметру 'a' */
        movl    12(%ebp), %eax   /* обращение к параметру 'b' */
        movl    16(%ebp), %eax   /* обращение к параметру 'c' */
        movl    20(%ebp), %eax   /* обращение к параметру 'd' */
```

Память на стеке под локальные переменные выделяется одной инструкцией:
```
        subl    $8, %esp
```

В стеке зарезервированы 8 байт, но их начальные значения не определены (точнее, это - мусор, оставшийся от предыдущего использования стека).
После выделения памяти на стеке работать с ней можно по отрицательным смещениям: `-4(%ebp)` - это первая переменная, `-8(%ebp)` - вторая переменная.

## Позиционно-независимый код

В примере вывода строки на стандартный поток вывода, рассмотренном выше, инструкция `push $msg1` заносит в стек **адрес** в памяти,
по которому размещается строка "Hello". При компоновке программы в исполняемый модуль будет получен такой фрагмент исполняемого файла:
```
08048460 <func>:
 8048460:	56                   	push   %esi
 8048461:	68 50 84 04 08       	push   $0x8048450
 8048466:	e8 a5 fe ff ff       	call   8048310 <printf@plt>
 804846b:	83 c4 08             	add    $0x8,%esp
 804846e:	c3                   	ret    
```

(для получения ассемблерного листинга использовалась команда `objdump --disassemble FILE`)

В этом фрагменте в инструкции вызова `call` для получения адреса, на который нужно переходить, испольуется смещение
`0xfffffea5` (байты a5 fe ff ff), а для загрузки в стек адреса строки, используется абсолютный адрес `0x08048450`
(байты 50 84 04 08).

Если мы заходим разместить исполняемый файл в памяти, начиная с другого адреса, а не с адреса `0x08048034`, инструкция `call`
останется без изменений (так как смещение не изменится при перемещении файла по памяти), а инструкция `push` потребует модификации.
Машинный код, настроенный на работу по фиксированным адресам в памяти, называется **неперемещаемым** (или позиционно-зависимым).

Такой код малопригоден для разделяемых библиотек, так как одна и та же библиотека может располагаться по разным адресам
в адресном пространстве разных процессов.

В **позиционно-независимом** (PIC) коде запрещено использование абсолютных адресов. Все адреса глобальных переменных и областей данных
должны вычисляться относительно текущего положения исполняемого кода.

Один из возможных способов реализации PIC-кода описан ниже.

Для получения текущей позиции в коде используется идиома:
```
        call    l1
l1:     popl    %eax
```

То есть мы "вызываем" следующую инструкцию программы, помеченную `l1`.
При этом в стек будет занесен адрес возврата (та же самая инструкция, помеченная `l1`), и затем будет
выполнен переход на саму же инструкцию, помеченную `l1`. После этого адрес инструкции достается из стека
с помощью инструкции `popl`.

```
        .text
msg1:   .asciz  "Hello, %d!\n"
        .align  16
        .global func
func:
        pushl   %esi            /* сразу заносим в стек второй аргумент printf */
        call    l1              /* получаем адрес, по которому размещаемся в памяти */
l1:     popl    %eax
        addl    $msg1-l1, %eax  /* прибавляем к адресу l1 смещение msg1 относительно l1 */
        pushl   %eax            /* заносим в стек получившийся абсолютный адрес */
        call    printf
        addl    $8, %esp        /* чистим стек */
        ret
```

## Косвенные переходы и вызовы подпрограмм

Для реализации операторов типа `switch`, или для реализации таблиц виртуальных функций, полезна возможность косвенного перехода или вызова подпрограммы.
Например, инструкция
```
        jmp     *%eax
```
выполнит переход по адресу, который располагается в регистре `%eax`, а инструкция `call *%eax` выполнит аналогичный вызов подпрограммы.

Предположим, что в регистре `%eax` передано некоторое значение от 0 до 3. Нам нужно перейти на метку `D0`, `D1`, `D2`, `D3` в зависимости о значения `%eax`.
```
        movl    jmptab(,%eax,4), %eax   // загружаем адрес из таблицы адресов
        jmp     *%eax                   // косвенный переход
jmptab: .int    D0, D1, D2, D3          // записываем адреса меток
```
