## Цель семинара
  * Понять: общую схему трансляции и запуска программ в операционной системе.
  * Научиться: компиляции и сборке программ на C++, состоящих из одного или нескольких файлов; отладке программ в среде Linux.

## Содержание семинара
  1. Исполняемый файл, запуск исполняемого файла операционной системой.
  2. Компиляция .cpp -> .o. Флаги компиляции.
  3. Препроцессор, заголовочные файлы, директива #include.
  4. Компоновка (линковка) исполняемого файла. Использование динамических и статических библиотек.
  5. Отладка программы с помощью gdb. Точки останова (breakpoints). Способы запуска отладчика.
  6. ~~Гадание~~ Отладка по coredump.

## Теоретическая справка

Процесс компиляции C/C++ можно разбить на 3 фазы: препроцессинг, трансляция и связывание объектного кода.

### Препроцессинг

На этой фазе обрабатываются *директивы препроцессора* - строки файла, начинающиеся с символа `#`. Две основные директивы:
  * `#include "file.h"` - заменяется на содержимое файла `file.h`. Важно понимать, что `#include` всего лишь подставляет
  один файл в другой. Например, если подключить один и тот же файл 2 раза, это скорее всего приведёт к ошибкам компиляции.
  Для решения этой проблемы применяются include guards или директива `#pragma once`.
  * `#define FOO bar` - заменяет все встречи строки символов `FOO` в файле, на строку `bar`.

**Пример 1:**

  math.h
  ```
  #define PI 3.1415

  double sin(double x);
  ```
  math.cpp
  ```
  #include "math.h"

  double cos(double x) {
      return sin(x + PI / 2);
  }
  ```
  math.cpp после обработки препроцессором
  ```
  double sin(double x);

  double cos(double x) {
      return sin(x + 3.1415);
  }
  ```

  **Важно**: использование `#define`-ов (макросов) в C++ является признаком плохого кода, так как макросы ухудшают читаемость кода. Для объявления глобальных констант лучше использовать конструкцию 
  
  ```static const ТИП ИМЯ = ЗНАЧЕНИЕ;```
  
  Это не только сделает код более понятным, но и даст компилятору возможность проверки ошибок, связанных с типизацией. Макросы `#define`, как правило, используются в двух случаях:
  
* Жесткая экономия памяти программ. Обычно, - при разработке программ для 8-битных микроконтроллеров, где ценится каждый байт. Использование макроса `#define`, в отличии от создания отдельной переменной, не приводит к затратам памяти на хранение этой переменной.
* Объявление значений для условной компиляции, в зависимости от целевой операционной системы, архитектуры или определенной конфигурации программы.


**Пример 2:**

config.h (как правило, сгенерированный файл)
```
#pragma once
#ifndef CONFIG_H
#define CONFIG_H

#define CONFIG_PLATFORM_WIN32
#define CONFIG_USE_EXTERNAL_LIB_VERSION 4

#endif  // CONFIG_H
```

usage.cpp
```
#include "config.h"
#include <some_external_great_library.h>
#include <iostream>

#ifdef CONFIG_PLATFORM_WIN32
    static const char PATH_SEPARATOR = '\\';
#else
    static const char PATH_SEPARATOR = '/';
#endif

void foo()
{
#if CONFIG_USE_EXTERNAL_LIB_VERSION >= 5
    ExternalLib::functionDeclaredSinceVersion5();
#else 
    ExternalLib::alternateFunctionDeclaredInOldVersion();
#endif

// значение NO_DEBUG может быть определено не в config.h,
// а передачей параметра в качестве опции компилятора
#ifndef NO_DEBUG
    std::cerr << "foo() executed" << std::endl;
#endif
}
```
  
  **Замечание**. Использование директивы `#pragma once` позволяет ускорить процесс компиляции, по сравнению с header guard.
  Тем не менее, необходимо всегда добавлять header guards в заголовочные файлы после `#pragma once`, - это необходимо для компиляторов, которые их не поддерживают данную директиву.
  
  
  **Пример 3:**
  
  base_module.h
  ```
  #pragma once
  #ifndef BASE_MODULE_H
  #define BASE_MODULE_H
  
  class Base {};
  
  #endif  // BASE_MODULE_H
  
  ```
  
  derived_module.h
  ```
  #pragma once
  #ifndef DERIVED_MODULE_H
  #define DERIVED_MODULE_H
  
  #include "base_module.h"
  
  class Derived: public Base {};
  
  #endif  // DERIVED_MODULE_H
  ```
  
  main.cpp
  ```
  #include "base_module.h"     // Загружено описание Base
  #include "derived_module.h"  // Загружено описание Derived, но не Base
  
  ```
  
  В данном примере, если препроцессор поддерживает `#pragma once`, то при обработке строки `#include "base_module.h"`
  он включает целиком содержимое файла `base_module.h` и запоминает, что этот файл уже был включен.
  
  При обработке строки `#include "derived_module.h"`, препроцессор включает и обрабатывает содержимое файла `derived_module.h`,
  где встречает строку `#include "base_module.h"`, но это строку он уже не обрабатывает, поскольку файл `base_module.h` уже 
  был включен ранее.
  
  Если препроцессор не поддерживает прагму `once` (она не является частью стандарта C++), то препроцессинг происходит немного
  по-другому. При обработке строки `#include "base_module.h"` в файле `main.cpp`, препроцессор включает и обрабатывает содержимое файла `base_module.h`. Строку `#pragma once` препроцессор игнорирует, возможно, выдав предупреждение о неизвестной
  прагме. В процессе его обработки, создается пустое макроопределение `BASE_MODULE_H`. При включении
  и обработке файла `derived_module.h`, когда компилятор встречает строку `#include "base_module.h"`, то он читает и обрабатывает файл "base_module.h", даже несмотря на то, что он уже был ранее включен. 
  В процессе повторной обработки этого файла, когда препроцессор встречает строку `#ifndef BASE_MODULE_H`, то он находит пустое, ранее созданное макроопределение `BASE_MODULE_H`, и поэтому пропускает все строки до `#endif` (или `#else`).
  


### Компиляция (трансляция)

На этой фазе, выход препроцессора преобразуется в машинный код. Результатом компиляции являются
  *объектные файлы*.

  Чтобы скомпилировать C++ файл, нужно выполнить команду `g++ my_file.cpp -c -o my_file.o`.
  * `-o my_file.o` - результат компиляции нужно записать в файл `my_file.o`.
  * `-c` - только компилировать. Без этой опции gcc попытается сразу сделать исполняемый файл.
  * `-S` - только компилировать, результат сохранить в виде текстового файла, содержащего ассемблерный код. Эта опция бывает полезна для изучения результата компиляции.
  * `-E` - выполнить только препроцессинг.

  Компилятору можно передавать дополнительные флаги, например:
  * `-Wall` - печатать предупреждения, об опасных конструкциях в коде.
  * `-Werror` - считать ошибками все предупреждения об опасных конструкциях в коде. Качественный код должен обязательно компилироваться с этой опцией.
  * `-O2` - включить оптимизации. По умолчанию код собирается без оптимизаций. Код, собраный с оптимизациями работает значительно быстрее. Другие возможные опции: `-O0` - отключить оптимизации, `-O1` - слабая оптимизация, `-O3` - агрессивная оптимизация, `-Os` - оптимизация размера кода, возможно, в ущерб производительности.
  * `-fPIC` - собрать Positional Independent Code. Необходимо для сборки shared библиотек.
  * `-std=c++11` - включить стандарт C++11. Можно явно указывать стандарты `c++98`, `c++03`, `c++11`, а для свежих версий компиляторов - `c++14`.
  * `-g` - добавляет в выходной файл отладочную информацию.
  * `-Ipath` - добавляет путь `path` в список путей поиска заголовочных файлов.
  * `-DИМЯ` - имитирует директиву препроцессора `#define ИМЯ`.
  * `-DИМЯ=ЗНАЧЕНИЕ` - имитирует директиву препроцессора `#define ИМЯ=ЗНАЧЕНИЕ`.
  

Чтобы скомпилировать Cи-файл (начиная со стандарта C99, этот язык уже заметно отличается от C++), вместо команды `g++` нужно использовать команду `gcc`. В данном случае можно указывать одну из опций, определяющий стандарт языка Си: `-ansi`, `-std=c99`, или `-std=c11`.

**Замечание.** Набор компиляторов GCC определяет исходный язык программы, руководствуясь именем входного файла:
 * `*.c` - файл на языке Си
 * `*.C`, `*.cc`, `*.cxx`, `*.cpp` - файл на языке C++
 * `*.m` - файл на языке Objective-C
 * `*.M`, `*.mm` - файл на языке Objective-C++.
 
Тем не менее, лучше не полагаться на эту особенность компилятора, и указывать явно правильные команды, вызывающие компилятор: `gcc` для языка Си и `g++` для языка C++.

Помимо команд `gcc` и `g++`, в UNIX-подобных системах можно использовать команды `cc` и `c++`, которые вызывают настроенные по умолчанию компиляторы Си или Си++. С системе Linux, как правило, эти команды являются символическими ссылками на `gcc` и `g++`. Помимо набора компиляторов GCC также часто используются компиляторы CLang (команды `clang` и `clang++`) и Intel (команды `icc` и `icpc`). Набор опций у этих компиляторов совместим с набором опций GCC, который мы будем использовать в рамках данного курса.


### Связывание (линковка)

На этом этапе объектные файлы объединяются в исполняемый файл или shared библиотеку.

Линковка выполняется с помощью команды `ld`, которой указываются входные объектные файлы и все используемые библиотеки, включая базовые. По этой причине, использовать команду `ld` не удобно, и обычно для линковки используется одна из команд: `gcc` или `g++`, которые, в свою очередь, вызывают `ld` с указанием нужных параметров.

  Чтобы получить исполняемый файл из нескольких объектных файлов, нужно выполнить команду
  `gcc my_file.o other_file.o -o myprog`

  Затем его можно запустить:
  `./myprog`
  
  **Замечание.** В данном примере подразумевается, что `my_file.o` и `other_file.o` являются продуктом компиляции Си-файлов. Если *хотя бы один* из объектных модулей реалован на С++, то эта команда завершится с ошибкой, поскольку линковщик будет использовать только Си-библиотеку и не найдет реализацию функций, специфичных для C++. В этом случае нужно использовать команду `g++`:
  `g++ my_file.o other_file.o -o myprog`
  

  Чтобы выполнить линковку с библиотекой, нужно указать ключ `-lmylib`, где `mylib` --- имя
  библиотеки, с которой нужно выполнить линковку. При этом библиотека должна находиться в списке
  путей поиска библиотек (определяется переменной окружения `LD_LIBRARY_PATH`), либо путь к библиотеке 
  может быть явно указан с помощью опции `-Lдополнительный_путь_к_библиотекам`.

## Отладка программ

Для отладки исполняемых файлов существуют отладчики. В среде Linux есть стандартный консольный отладчик gdb. Управление отладчиком происходит через командный интерфейс (список самых частых команд приведен ниже).
Отладчик gdb можно использовать в трех режимах:

1. Запускать в нем исполняемый файл

 `gdb ./myprog`

 После того, как отладчик загрузил исполняемый файл и готов к работе, можно запустить исполняемый
 файл.
 В командной строке gdb наберите

 `> run`

3. Отладка при помощи [дампа
   памяти](https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D0%BC%D0%BF_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8) процесса (coredump).

 Как правило, дамп памяти сохраняется, когда процесс завершается из-за критической ошибки (например,
 ошибки сегментации). В этом случае, проанализировав дамп памяти, иногда можно понять, что послужило
 ошибкой.

 `gdb myprog /path/to/core`

 По умолчанию Linux сохраняет дампы памяти в директорию `/proc/sys/kernel/core_pattern`.


 Чтобы система сохраняла дамп памяти в случае завершения процесса из-за критической ошибки, нужно
 выполнить

 `ulimit -c unlimited`


2. Присоединяться к запущенному процессу

 Если процесс запущен и работает (например, это системный демон или web-сервер),
 то можно при помощи отладчика, например, посмотреть на его состояние,
 поставить точку останова в определенной функции.

 Для этого необходимо узнать идентификатор процесса PID, к которому мы хотим подключиться, а затем
 выполнить

 `gdb --pid PID`

 Либо можно запустить `gdb`, а в его командной строке выполнить

 `gdb attach PID`

 Команду `run` при этом выполнять не нужно.

 Для отладки запущенного процесса необходимо обладать правами не ниже, чем права запущенного процесса.

 Часто используемые команды отладчика gdb (указан длинный и короткий варианты команды, использовать
 можно любой):
 * `backtrace`, `bt` -- просмотреть стек вызовов;
 * `print x`, `p x` -- просмотреть значение переменной `x`;
 * `display x` -- отображать значение выражения `x` каждый раз при остановке программы;
 * `break`, `b` -- поставить точку останова (breakpoint). Дойдя до этой точки, выполнение процесса
  прервется, вы снова получите доступ в командную строку `gdb`;
 * `next`, `n` -- перейти к следующей строке программы;
 * `list`, `l` -- просмотреть исходный код текущей строки программы и 50 строк после нее;
 * `continue`, `c` -- продолжить выполнение;
 * `step`, `s` -- перейти внутрь функции, находящейся на текущей строке;
 * `finish` -- вернуться на уровень выше (выйти из функции);
 * `help`, `h` -- показать справку, из которой можно узнать другие полезные команды.
 

3. Отладка программы на другом компьютере

Иногда бывает необходимо выполнять отладку программы, которая выполняется на другом компьютере. Например, если программа отлаживается на удаленном сервере с необходимым окружением, или на микроконтроллере.

Для этого существует команда `gdbserver`, которая должна запускаться на целевом компьютере вместо команды `gdb`:

```
# запуск программы ./myprog 
# на сервере myserver.local с использованием TCP-порта 1234
gdbserver myserver.local:1234 ./myprog     

# присоединение к запущенному процессу
# на сервере myserver.local с использованием TCP-порта 1234
gdbserver --attach myserver.local:1234 PID
 
# запуск программы ./firmware
# на ARM-контроллере с использованием UART-интерфейса
gdbserver /dev/ttyS0 ./firmware
```

Для соединения с сервером используется команда `gdb`, после запуска которой нужно указать использование удаленной цели:

```
> target remote localhost:1234
```

**Замечание.** При использовании отладки через TCP/IP, необходимо убедиться, что выбранный номер порта не блокируется firewall'ом.


## Задание

1. В файле `bc.cpp` реализован калькулятор арифметических выражений. Он представляет из себя простой REPL.
  Сначала по входной строке строится дерево разбора (функция `Parse()`), затем это дерево вычислется (фукция `Eval()`).
  В файле `ast.h` находятся определения структур, из которых состоит дерево разбора (**не путать с деревом поиска!**).

  Скомпилируйте файл `bc.cpp` и запустите получившийся исполняемый файл. Вычислите значение выражения 1 + 2 * 3.

  *Note: В калькуляторе используется класс `std::unique_ptr`, появивившийся в стандарте c++11. Чтобы файл скомпилировался,
  нужно указать компилятору опцию `-std=c++11`.*

  *Note: Для выхода из калькулятора используйте сочетание клавиш Ctrl+C.*

2. Логику работы необходимо отделить от обработки входных данных и вывода результата и выделить в отдельный файл.
  Поместите функции `Parse()` и `Eval()` в файл `calc.cpp` и прототипы этих функций в `calc.h`. Скомпилируёте файлы `calc.cpp` и `bc.cpp` в
  один исполняемый файл. Убедитесь, что калькулятор запускается.

3. Запустите исполняемый файл и вычислите значение выражения 42 / 0. Что произошло с программой?
  Запустите программу под отладчиком и снова вычислите значение выражения 42 / 0. Можете ли Вы найти строку программы, в которой происходит ошибка?

  Пересоберите калькулятор с отладочной информацией, снова запустите программу под отладчиком. Найдите строчку в программе, на которой происходит ошибка.

  Измените программу так, чтобы вместо деления на ноль она бросала исключение. 

## Домашнее задание
1. В файле `calc_test.cpp` находятся юнит-тесты. Тесты используют библиотеку gtest.
  Скомпилируйте файлы `calc_test.cpp` и `calc.cpp` вместе с библиотекой `gtest/libgtest.a` в один исполняемый файл. Запустите тесты,
  убедитесь что они проходят.
 Добавьте тест, проверяющий что программа больше не падает при делении на 0.

  *Note: Библиотека gtest использует системную библиотеку pthread. Чтобы подключить её, нужно добавить флаг -lpthread.*

2. Что делать, если программа падает, но у вас нет входных данных, на которых это происходит?
  Включите запись coredump. Затем запустите скрипт compute.sh.
  Запустите отладчик на получившимся core файле. Найдите строчку в программе, на которой произошла ошибка.
  Исправьте ошибку. Добавьте тест, проверяющий что ошибка исправлена.

<!---
**TODO:** инструкция по сдаче лабы на автоматическую проверку.
-->

## Дополнительное задание
Линковка может происходить не только на этапе компиляции, но и в момент запуска программы. Этот случай называют *динамической* линковкой.
Вы уже видели, как можно указать, что к программе нужно прилинковать динамическую библиотеку (флаг -lpthread). При встрече этого флага, компилятор
вставляет в исполняемый файл информацию, которая используется динамическим линковщиком. Эту информацию можно посмотреть в любой момент, с помощью
команды ldd (посмотрите, какие динамические библиотеки использует python).

Существует возможность в момент запуска прилинковать динамическую библиотеку, даже если её не указывали в момент компиляции. Для этого используется
переменная окружения `LD_PRELOAD`. Например: `LD_PRELOAD=libmyoverrides.so ./bc`. При этом, если в динамической библиотеке будут объявлены какие-то
функции, которые уже есть в исполняемом файле, будут использованы реализации функций из динамической библиотеки. Это позволяет менять поведение
уже скомпилированных программ.

Запустите файл `my_login`. Для своей работы он просит пароль. Вам не известно, по какому алгоритму определяется валиндость пароля, зато известно,
что этой проверкой занимается функция с сигнатурой `bool is_password_valid(char* passwd);`. Напишите реализацию функции, которая считать любой пароль
правильным. Скомпилируйте файл с этой функцией в динамическую библиотеку. Загрузите библиотеку с помощью `LD_PRELOAD` и добейтесь того, чтобы программа
приняла пароль.

<!--
**TODO** Бинарник для доп задания
-->

## Вопросы

1. Напишите команду, которая скомпилирует файлы `a.cpp`, `a.h` и `b.cpp` в один исполняемый файл.
2. Почему нельзя скомпилировать файлы bc.cpp calc.cpp и bc_test.cpp в один исполняемый файл?
3. Можно ли линковать вместе объектные файлы, собранные с разными уровнями оптимизации?
4. Почему нельзя писать тело функции в заголовочном файле?
5. В чем преимущество отладки по coredump-у перед отладкой работающего процесса? В чем состоят недостатки?
6. Можно ли include-ить .cpp файлы?
7. Должен ли .h файл содержать синтаксически корректную программу?
