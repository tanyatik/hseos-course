# Ассемблер x86, часть 1

Основное чтение: Р. Э. Брайант, Д. Р. О'Халларон. Компьютерные системы: архитектура и программирование. Глава 3.

Мы будем использовать AT&T синтаксис для записи инструкций ассемблера x86. Для компиляции программ будем использовать gas,
а точнее gcc.
```bash
gcc -m32 prog.S -o prog
```

Исходный файл с программой на ассемблере должен иметь суффикс .S (буква S должна быть заглавной!).
Файл будет обрабатываться препроцессором, затем ассемблером.

На 64-битной Ubuntu может быть не установлена поддержка компиляции программ для 32-битной архитектуры i386. В этом случае
даже простейшая программа, приведенная ниже, не скомпилируется. Чтобы установить 32-битные библиотеки выполните команду: 
```bash
sudo apt-get install gcc-multilib
```

## Регистры

x86 имеет 8 32-битных регистров общего назначения, которые называются
`%eax`, `%ebx`, `%ecx`, `%edx`, `%esi`, `%edi`, `%ebp`, `%esp`.
Регистр `%esp` - указатель стека и всегда используется в этих целях.
Регистр `%ebp` - указатель фрейма, то есть области данных текущей функции.
Он может использоваться и как регистр общего назначения, но мы этого делать
не будем. Таким образом для вычислений остается 6 регистров `%eax`, ...,
`%edi`. Из них регистр `%eax` используется для возврата 32-битного
значения из функции, а пара регистров `%eax`, `%edx` - для возврата
64-битного значения. В любом случае вызываемая функция может испортить
регистры `%eax`, `%ecx`, `%edx`, но состояние остальных регистров она
обязана сохранить. Итого для хранения промежуточных результатов вычислений
осталось три регистра: `%ebx`, `%esi`, `%edi`.

В некоторых случаях необходимо использовать младшие байты 32-битных регистров,
работать с которыми можно как с 8-битовыми регистрами `%al`, `%bl`, `%cl`,
`%dl`. При манипуляциях с младшим байтом остальные байты регистра не
изменяются. 

## Инструкции

Инструкция имеет вид:
```
LABEL:  OPCODE  ARGS
```

Где `LABEL` - необязательная метка, которую можно использовать в других местах
программы для перехода или загрузки адреса. Можно считать, что метка - это
адрес, по которому находится данная инструкция программы.

`OPCODE` - мнемоника операции. Полный набор инструкций x86 очень велик,
мы будем использовать маленькое подмножество.

`ARGS` - аргументы операции. У двухадресной операции операнд-приемник
результата всегда пишется вторым.

Примеры:
```gas
        movl    %eax, %ebx
```
Переслать (присвоить, скопировать) содержимое регистра `%eax' в регистр `%ebx`.

```gas
        incl    %esi
```
Увеличить значение `%esi` на 1.

```gas
        subl    $4, %edi
```
Вычесть число 4 из значения `%edi` и сохранить результат обратно в `%edi`.

## Некоторые инструкции

```gas
        addl    SRC, DST        /* DST += SRC */
        subl    SRC, DST        /* DST -= SRC */
        incl    DST             /* ++DST */
        decl    DST             /* --DST */
        negl    DST             /* DST = -DST */
        movl    SRC, DST        /* DST = SRC */
        imull   SRC             /* (%eax,%edx) = %eax * SRC - знаковое */
        mull    SRC             /* (%eax,%edx) = %eax * SRC - беззнаковое */
        andl    SRC, DST        /* DST &= SRC */
        orl     SRC, DST        /* DST |= SRC */
        xorl    SRC, DST        /* DST ^= SRC */
        notl    DST             /* DST = ~DST */
        cmpl    SRC, DST        /* DST - SRC, результат не сохраняется, */
        testl   SRC, DST        /* DST & SRC, результат не сохраняется  */
        adcl    SRC, DST        /* DST += SRC + CF */
        sbbl    SRC, DST        /* DST -= SRC - CF */
```

Операции умножения оставляют результат - 64-битное значение в паре регистров
%eax (младшая часть) и %edx (старшая часть).

## Вызов/возврат из подпрограмм

```gas
        call    label           /* вызов подпрограммы */
        ret                     /* возврат из подпрограммы */
```

## Ввод-вывод

Сначала мы будем использовать для ввода-вывода маленькую библиотеку simpleio.S.

Простейшая программа на ассемблере будет выглядеть так:
```gas
#include "simpleio.S"
        .text           /* секция кода программы */
        .global main    /* экспортируем точку входа - функцию main */
main:
        call    finish  /* вызываем подпрограмму finish: exit(0) */
```

Чтение целого числа со стандартного потока ввода:
```gas
        /* фрагмент программы */
        call    readi32
```
По возращению в регистре `%eax` находится считанное число. Если произошла
ошибка преобразования или был достигнут конец файла, флаг CF устанавливается,
а при успешном чтении сбрасывается.

Вывод целого числа на стандартный поток вывода:
```gas
        call    writei32
```
перед вызовом в регистр `%eax` должно быть помещено выводимое число.

Вывод символа \n:
```gas
        call    nl
```

Чтение 64-битного числа со стандартного потока ввода:
```gas
        call    readi64
```
По возращению в регистрах `%eax` (младшие 32 бита) и `%edx` (старшие 32 бита) находится считанное число.
Если произошла ошибка преобразования или был достигнут конец файла,
флаг CF устанавливается,
а при успешном чтении сбрасывается.

Вывод 64-битного целого числа на стандартный поток вывода:
```gas
        call    writei64
```
перед вызовом в регистры `%eax` (младшие 32 бита), `%edx` (старшие 32 бита) должно быть помещено выводимое число.

## Арифметические флаги

Большинство арифметических инструкций в результате вычисления результата
инструкции устанавливают арифметические флаги слова состояния процесса.
Флаг ZF устанавливается, если в результате операции был получен нуль.
Флаг SF устанавливается, если в результате операции было получено
отрицательное число.
Флаг CF устанавливается, если в результате выполнения операции произошел
перенос из старшего бита результата. Например, для сложения CF устанавливается
если результат сложения двух беззнаковых чисел не может быть представлен
32-битным беззнаковым числом.
Флаг OF устанавливается, если в результате выполняния операции произошло
переполнение знакового результата. Например, при сложении OF устанавливается,
если результат сложения двух знаковых чисел не может быть представлен
32-битным знаковым числом.

Обратите внимание, что и сложение `addl`, и вычитание `subl` устанавливают
одновременно и флаг CF, и флаг OF. Сложение и вычитание знаковых и беззнаковых
чисел выполняется совершенно одинаково, и поэтому используется одна инструкция
и для знаковой, и для беззнаковой операции.

## Переходы

Безусловный переход выполняется с помощью инструкции jmp
```gas
        jmp label
```

Условные переходы проверяют комбинации арифметических флагов:
```gas
        jz      label   /* переход, если равно (нуль), ZF == 1 */
        jnz     label   /* переход, если не равно (не нуль), ZF == 0 */
        jc      label   /* переход, если CF == 1 */
        jnc     label   /* переход, если CF == 0 */
        jo      label   /* переход, если OF == 1 */
        jno     label   /* переход, если OF == 0 */
        jg      label   /* переход, если больше для знаковых чисел */
        jge     label   /* переход, если >= для знаковых чисел */
        jl      label   /* переход, если < для знаковых чисел */
        jle     label   /* переход, если <= для знаковых чисел */
        ja      label   /* переход, если > для беззнаковых чисел */
        jae     label   /* переход, если >= (беззнаковый) */
        jb      label   /* переход, если < (беззнаковый) */
        jbe     label   /* переход, если <= (беззнаковый) */
```

## Секции исполняемого файла

```gas
        .text
```
Это секция кода. В ней размещается код программы и данные только на чтение.

```gas
        .data
```
Это секция данных. Данные в этой секции можно модифицировать

## Определение данных

```gas
        .asciz  "a string"
```

Определяет строку, завершающуюся нулем.

```gas
        .space  SIZE, FILL
```
Выделяет пространство размера SIZE, заполненное байтом FILL, например,
```gas
        .space  64 * 4, 0
```
Выделяет место для глобального массива типа int из 64 элементов.

```gas
        .int    20
```
Выделяет место для глобальной 32-битной переменной с начальным значеним 20.

```gas
        .quad   -1
```
Выделяет место для глобальной 64-битной переменной с начальным значением -1.

Как правило, определение данных должно быть помечено. Например,
```gas
str1:   .asciz  "Hello, there\n"
```

Затем метка `str1` может использоваться в программе:
```gas
        movl    $str1, %esi
```
в этом случае адрес памяти, по которому размещается строка `str1` будет загружен в регистр `%esi`.

## Работа с памятью

Как правило, аргумент одноадресных команд (например, `incl`), или один из аргументов двухадресных команд
(например, `addl`) может обращаться к памяти. Аргумент инструкции, обращающийся к памяти, имеет следующий общий вид:
```
        OFFSET(BASE-REG,INDEX-REG,SCALE)
```

`OFFSET` - это 32-битное значение, которое можно рассматривать либо как смещение, либо как базовый адрес в памяти.

`BASE-REG` - это регистр процессора.

`INDEX-REG` - это регистр процессора.

`SCALE` - это число 1, 2, 4, 8 - масштаб.

Адрес для обращения к памяти вычисляется по формуле OFFSET + BASE-REG + INDEX-REG * SCALE.

Примеры:
```gas
        movl    (%eax), %eax    /* в регистр %eax записать 4 байта, */
                                /* расположенные по адресу, который хранился изначально в %eax */
        movl    %ecx, -8(%ebx)  /* сохранить значение из регистра %ecx по адресу %ebx - 8 */
        movl    arr(,%esi,4), %eax /* в регистр %eax записать значение, */
                                   /* расположенное по адресу arr + %esi * 4 */
        movl    -64(%ebp,%esi,4), %eax /* в регистр %eax записать значение, */
                                       /* расположенное по адресу %ebp - 64 + %esi * 4 */
```

## Очистка и установка значения регистра

Чтобы очистить (обнулить) регистр, обычно используется инструкция `xorl`.

```
        xorl    %esi, %esi      // %esi = 0
```

Чтобы загрузить константное значение (в частности, метка - это константное значение, равное адресу
размещения соответствующей инструкции в памяти) используется непосредственный аргумент, например:

```
        movl    $1, %eax        // %eax = 1
        movl    $0xff, %ebx     // %ebx = 0xff
        movl    $arr, %edx      // в %edx поместить адрес, по которому размещается инструкция,
                                // помеченная addr
```

Непосредственный аргумент может быть первым операндом у двухадресных инструкций (`addl`, etc).

## Дополнительное чтение: 

1. [Вики-учебник "Ассемблер в Linux для программистов C"](https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C).

2. Учебное пособие для курса ВМК "Архитектура ЭВМ и язык 
ассемблера": [часть 1](http://asmcourse.cs.msu.ru/wp-content/uploads/2015/03/asm-ucebnice-1.pdf), [часть 2](http://asmcourse.cs.msu.ru/wp-content/uploads/2015/02/asm-ucebnice-2.pdf).

3. [Материалы лекций курса ВМК "Архитектура ЭВМ и язык ассемблера"](http://asmcourse.cs.msu.ru/?page_id=1251).
